![CI](https://github.com/brivazz/vrnnrmnvldmrvch_tz/actions/workflows/code-checker.yml/badge.svg)
![GitHub last commit (by committer)](https://img.shields.io/github/last-commit/brivazz/vrnnrmnvldmrvch_tz)

# Тестовое задание для Python-разработчика

---

### Задание

**Часть 1: Разработка Django-приложения**

1. Создайте Django-приложение для управления книгами в библиотеке. Каждая книга должна иметь следующие атрибуты:
    - Название
    - Автор
    - Год издания
    - ISBN
2. Реализуйте REST API для управления книгами. API должно предоставлять эндпоинты для:
    - Получения списка всех книг.
    - Получения информации о конкретной книге.
    - Создания новой книги.
    - Обновления информации о книге.
    - Удаления книги.

---

**Часть 2: Работа с базой данных и Celery**

1. Используя Django ORM, создайте модель для хранения информации о пользователях приложения. Модель должна содержать следующие поля:
    - Имя пользователя
    - Электронная почта
    - Дата регистрации (автоматически заполняется при создании пользователя)
2. Используя Celery, реализуйте асинхронную задачу, которая отправляет приветственное электронное письмо пользователю при его регистрации.
3. Обновите API для работы с пользователями, добавив эндпоинт для регистрации нового пользователя. При создании нового пользователя, задача Celery должна запускаться асинхронно для отправки приветственного письма.

---

**Часть 3: Работа с Git и системой контроля версий**

1. Создайте отдельную ветку для разработки новой функциональности в вашем репозитории Git. Назовите ветку, например, `feature/book-management`.
2. Внесите несколько изменений в код, связанных с API для управления книгами. Коммиты должны быть информативными и содержательными.
3. Используя механизм ветвления в Git, создайте отдельную ветку для исправления ошибки в коде вашего приложения. Назовите ветку, например, `bugfix/registration`.
4. Создайте Pull Request (или Merge Request) для слияния веток обратно в основную ветку вашего проекта. Убедитесь, что код проходит проверку тестов и успешно ревью.

---

**Часть 4: Работа с Docker и Redis**

1. Создайте Dockerfile для вашего Django-приложения. Включите все необходимые зависимости.
2. Создайте файл docker-compose.yml, чтобы ваше приложение могло успешно запускаться в контейнере. Включите в файл сервис для вашей базы данных MySQL и для Redis (используемого Celery в качестве брокера).
3. Убедитесь, что приложение в контейнере успешно подключается к MySQL и Redis.

**Часть 5: Docker**

1. Разверните ваше Django-приложение в контейнерах Docker.
2. Создайте Dockerfile для вашего Django-приложения. Учтите все необходимые зависимости, включая установку пакетов из файла зависимостей (requirements.txt).
3. Создайте файл docker-compose.yml для контейнеризации вашего приложения. Определите сервисы для Django-приложения, базы данных MySQL и брокера сообщений Celery (Redis).
4. Убедитесь, что ваше приложение в контейнере успешно подключается к базе данных MySQL и Celery внутри их собственных контейнеров.
5. Добавьте команды в docker-compose.yml для инициализации базы данных и применения миграций Django при первом запуске.
6. Предоставьте в README инструкции по сборке и запуску контейнеров. Укажите, как пользователь может взаимодействовать с вашим Django-приложением, находящимся в контейнере.

---

**Примечание:**
Удостоверьтесь, что ваши контейнеры настроены таким образом, чтобы приложение успешно работало в среде Docker.

**Критерии оценки:**

- Корректность и полнота реализации каждого шага задания.
- Чистота и структурированность кода.
- Использование Django-паттернов и лучших практик.
- Наличие комментариев в коде, где это необходимо.
- Успешное выполнение всех шагов задания, включая работу с Git, Docker и Celery.

**Важно**:
Пришлите решение задания в виде ссылки на репозиторий (например, на GitHub). Убедитесь, что ваш репозиторий содержит README файл с инструкциями по запуску приложения и любыми другими необходимыми деталями.

---

### Используемые технологии сервиса

Технологический стек проекта:

1. [Nginx](https://nginx.org/ru/) - Веб-сервер
2. [MySQL](https://www.mysql.com/) - Свободная реляционная система управления базами данных
3. [Django](https://www.djangoproject.com/) - Свободный фреймворк для веб-приложений на языке Python, использующий шаблон проектирования MVC
4. [Django REST framework](https://www.django-rest-framework.org/) - Мощный и гибкий инструментарий для создания веб-API
5. [Celery](https://docs.celeryq.dev/en/stable/) - Асинхронная очередь задач с открытым исходным кодом, основанная на распределенной передаче сообщений
6. [Redis](https://redis.io/) - (REmote DIctionary Server, «удалённый серверный словарь») — это нереляционная резидентная СУБД
7. [GitHub Actions](https://docs.github.com/ru/actions) - для реализации CI

Сервис запускается с помощью Docker контейнеров, тем самым реализуя в проекте микросервисную архитектуру. Сервисы связаны между собой с помощью docker compose.

---

### Подготовка к запуску "Тестовое задание для Python-разработчика"

1. Для работы сервиса у Вас должен быть установлен [Python](https://www.python.org/) на локальной машине и [Docker](https://www.docker.com/)

2. В корневой директории проекта создайте файл `.env` и скопируйте в него содержимое файла [.env.example](https://github.com/brivazz/vrnnrmnvldmrvch_tz/blob/main/.env.example) или переименуйте его в .env

# Запуск

В проекте предусмотрен Makefile для удобства запуска проекта.

Для запуска проекта достаточно:

1. Команда `make start` запустит docker-compose и drf api будет доступно для запросов по адресу: <http://127.0.0.1:80/api/>
   - Веб-сервер Nignx будет проксировать запросы на 8000 порт приложения. Приложение также доступно на этом порту.
   - Документация OpenAPI (документация в формате Swаggеr) проекта, доступна по адресу: <http://127.0.0.1:80/> с помощью которой, есть возможность вручную ввести данные на вход приложению.
   - Для удобства просмотра запущенных асинхронных задач и результата их выполнения в проекте присутствует веб-инструмент [flower](https://flower.readthedocs.io/en/latest/man.html), который обеспечивает наглядность настроек Celery и предоставляет функции для просмотра хода выполнения задачи.

# Остановка

Команда `make stop` остановит и удалит все контейнеры, вместе со всеми созданными файлами(volumes).
